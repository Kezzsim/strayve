#!/usr/bin/env node

/**
 * Module dependencies.
 */
var app = require('../app');
var fs = require('fs');
var debug = require('debug')('shizukadisco:server');
var http = require('http');
var program = require('commander');
var internetradio = require('node-internet-radio');
var Moniker = require('moniker');
var ip = require('ip');
var socket = require('socket.io');
const chalk = require('chalk');
const chalkAnimation = require('chalk-animation');


var currentTrack;
var roster = [];
var init = true;

/**
 * Get the stream URL from the User starting the server via CLI
 */
program
  .version('0.1.0')
  .arguments('<streamURL>')
  .option('-i, --icecast', 'Stream is of the IceCast variety')
  .option('-s, --shoutcast1', 'Stream is of the shoutcast1 variety')
  .option('-S, --shoutcast2', 'Stream is of the shoutcast2 variety')
  .action(function(streamURL) {
    stream = streamURL;
  });

program.parse(process.argv);
var flags = ((process.argv.includes("-s") || process.argv.includes("--shoutcast1")) || (process.argv.includes("-S") || process.argv.includes("--shoutcast2")) || (process.argv.includes("-i") || process.argv.includes("--icecast")));

if (typeof stream === 'undefined') {
  console.error(chalk.red.bold.bgWhite('Please add your Stream URL from IceCast or elsewhere in the command line - eg : ' + chalk.green.cyanBright('strayve http://myIPaddress/mystream.mp3')));
  process.exit(0);
} else if (stream.includes(".pls") || stream.includes(".m3u") || stream.includes(".xspf")) {
  console.error(chalk.red.bold.bgWhite('Please get direct link to stream - eg :' + chalk.cyanBright(' .mp3, .m4a, .ogg') + " : we'll try to walk up from there"));
  process.exit(0);
}

/**
 * Then start by putting our server's IP in a place where our Client can get it, this can include other credentials.
 */

fs.writeFile("tmp/connect.json", JSON.stringify({
  ip: ip.address(),
  port: (process.env.PORT || '3000'),
  url: stream
}), function(err) {
  if (err) {
    return console.log(err);
  }
});

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
if (!process.env.PORT) {
  console.log(chalk.bgYellow("Running on Port " + chalk.greenBright.bold(port) + ". For use at events with external routing, run as root and add PORT before the rest of your command - eg :" + chalk.cyanBright(" sudo PORT=80 strayve " + (stream || "http://localhost/mystream.mp3"))));
}
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string' ?
    'Pipe ' + port :
    'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string' ?
    'pipe ' + addr :
    'port ' + addr.port;
  debug('Listening on ' + bind);
}

/**
 * Web Socket setup.
 * Clients have randomized names associated with their IDs in the cliEnt object
 */

function disp() {
  setTimeout(() => {
    console.clear();
    console.log((!roster.length) ? chalk.bgWhite.grey("Server Address: " + ip.address() + " || NO CLIENTS") : chalk.bgGreen.bold("Server Address: " + ip.address() + " || Active Clients:"));
    roster.forEach(function(clint) {
      console.log(chalk.bgGreen(clint.name));
    });
    chalkAnimation.neon("Now Playing: " + currentTrack.replace(/[^a-zA-Z ]/g, "") + "\n");
  }, 5000);
}

function initDisp() {
  console.clear();
  if (!flags) {
    console.log(chalk.bgBlue.white("No streamtype argument found - trying ShoutCast V1 - otherwise add " + chalk.cyanBright("-i") + " or " + chalk.cyanBright("--icecast") + " for Icecast || " + chalk.cyanBright("-S") + " for Shoutcast V2"));
    program.shoutcast1 = true;
  }
  //console.log(chalk.bgMagenta(currentTrack));
  chalkAnimation.radar("Waiting for stray ravers... Now Playing : " + currentTrack.replace(/[^a-zA-Z ]/g, "") + "\n");
}

function notifire(clist) {
  if (!roster.includes(clist)) {
    roster.push(clist);
    chalkAnimation.rainbow(clist.name + " Connected!");
    disp();
  } else {
    chalkAnimation.pulse(clist.name + " left...");
    var i = roster.indexOf(clist);
    roster.splice(i, 1);
    disp();
  }
  io.sockets.emit('peerList', roster);
}

var names = Moniker.generator([Moniker.adjective, 'friendsname.txt']);
var io = socket(server);
io.on('connection', function(socket) {
  init = false;
  var cliEnt = {
    id: socket.id,
    name: names.choose()
  };
  socket.emit('nowPlaying', currentTrack);
  notifire(cliEnt);

  socket.on('disconnect', function() {
    notifire(cliEnt);
  });
});

/**
 * Event listener for the stream parser to get new Metadata.
 * Test with Traktor, splits the URL for the user so we don't need a Mount argument
 */

// update currentTrack only when song name changes
function onAir(title) {
  if (typeof currentTrack === 'undefined' || title.title != currentTrack) {
    currentTrack = title.title;
    io.sockets.emit('nowPlaying', currentTrack);
    (init) ? initDisp() : disp();
  }
}

// handle no stream type input
if (!program.shoutcast1 && !program.shoutcast2 && !program.icecast) {
  console.log(chalk.bgBlue.white("No streamtype argument found - trying ShoutCast V1 - otherwise add " + chalk.cyanBright("-i") + " or " + chalk.cyanBright("--icecast") + " for Icecast || " + chalk.cyanBright("-S") + " for Shoutcast V2"));
  program.shoutcast1 = true;
}

// loop to get title
var titleLoop = setInterval(function() {
  //hopefully commander stores these with names so we won't NEED the ternary operations to have them produce strings
  internetradio.getStationInfo(stream.substr(0, stream.lastIndexOf("/")), function(error, station) {
    onAir(station);
  });

}, 1000);
